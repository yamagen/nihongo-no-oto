## 正しく失敗するコード — 明示性と責任の設計論


Last change: 2025/07/27-00:30:14.

---

### 概要

LEAP のメール認証システムの改良作業を通じて、私たちは「保険的コード」がもたらす曖昧さに直面した。
`rtrim()` や `trim()` は一見便利な保護措置に見えるが、実際には設計上の誤りを覆い隠し、責任を曖昧にする。
本稿では、「動くこと」ではなく「正しいこと」に価値を置く設計姿勢こそが、堅牢なプログラミングの本質であると論じる。

---

### 本文

2025年7月26日、plover 上で LEAP のトークン処理ロジックをデバッグしている際、次のようなコードが問題となった：

```php
$dataDir = rtrim($config['token_data_dir'], '/') . '/';
```

なぜ `rtrim()` が必要なのか？
それは設定ファイルでスラッシュを付け忘れるかもしれない、という理由である。

だが、それは本来プログラムの責任ではない。
このようなコードは「ミスしてもなんとかする」という思想に基づいている。
その結果、設定ファイルとコードの間にあるべき契約は曖昧になり、責任の所在が不明瞭になる。

代わりに、次のように書くべきである：

```php
// config.php
// ディレクトリパスは必ず末尾を '/' にすること。
'token_data_dir' => __DIR__ . '/data/tokens/',
```

プログラム側ではこの約束を前提として、次のように明示的に失敗させる：

```php
if (substr($config['token_data_dir'], -1) !== '/') {
    throw new RuntimeException("token_data_dir は末尾に '/' を含めてください。");
}
```

しかし、このようなチェック自体もまた設計の敗北を意味している。
本来なら、設定値の書き方が明示的であれば、こうしたチェックすら不要なはずである。
失敗を防ぐのではなく、失敗が起きないように設計しなければならない。

---

### trim()という「お掃除」の欺瞞

同じようなことは `trim()` にも言える：

```php
$json = file_get_contents($tokenFile);
if ($json === false || trim($json) === '') {
    echo "トークンファイルの読み込みに失敗しました。";
    exit;
}
```

あるいは、

```php
$token = trim($token);
```

こうしたコードは「万が一」のための予防措置として書かれる。
だが、データが正しくない可能性があるなら、それは入力側の問題であり、trim で誤魔化すべきではない。

`trim()` は失敗を隠蔽し、開発者に「安心していい」と錯覚させる。
結果として、責任の分界が曖昧になり、設計全体の信頼性が損なわれる。

良い設計とは、「入力はこうであるべき」と契約を明示し、それが守られなければ止まることである。

---

### 失敗する勇気と仮説の規律

`trim()` や `rtrim()` は一種の嘘である。
「少しぐらい間違っていても直してあげよう」という姿勢は、実は仮説検証を放棄している。

本来、プログラミングは科学的であるべきだ。

1. 仮説を立てる。
2. 一箇所だけ変更する。
3. 動かなければ元に戻す。

この繰り返しこそが、学習であり設計の鍛錬である。
保険的コードは、エラーを隠してしまい、学ぶ機会を奪ってしまう。

---

### 結論

コードは、正しい前提のもとでのみ動作すべきである。
前提が崩れたときは、止まるべきであり、それを明示すべきである。

これは意地悪ではなく、信頼のためである。
`rtrim()` や `trim()` による保護は、頑丈さではなく、恐れによる設計である。

私たちは、曖昧さを許容する文化ではなく、明示的な設計を尊ぶ文化を築いていかなければならない。

---

### メモ・タグ・関連プロジェクト

* 関連プロジェクト: LEAP, p-leap
* タグ: プログラミング教育, 例外処理, 頑健性, デバッグ, 明示的設計, 設定ファイルの設計


